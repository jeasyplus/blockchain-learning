# BTC数据结构

## Hash Pointers

Hash指针不仅包括地址信息（指针），还有结构体的Hash值。

## 区块链与普通链表的区别

Hash指针代替了普通的指针。

B lock chain is a linked list using hash pointers

第一个区块 叫 genesis block
最后一个区块 叫 most recent block


### tamper-evident log

后一个区块的hash值包含了前面区块，形成一个tamper-evident log


防篡改日志（Tamper-Evident Log）是一种记录系统，用于确保记录内容的完整性和不可篡改性。这种日志的主要特征包括：

不可篡改性：一旦数据被写入日志，任何对日志内容的篡改都会被检测到，确保记录的真实性。

时间戳：日志条目通常带有时间戳，提供事件发生的确切时间，有助于事件的追踪和审计。

完整性校验：使用加密哈希函数（如SHA）对日志条目进行哈希，生成一个指纹。当日志内容被更改时，相应的哈希值也会发生变化，便于检测篡改。

链式结构：许多防篡改日志采用链式结构，将每个新条目与前一个条目相关联，形成一个不可分割的链。即使某个条目被篡改，其后续条目的哈希也会不一致，从而暴露篡改行为。

存储分散性：在一些应用中，日志可能会被分散存储在多个位置，增加篡改的难度。

防篡改日志广泛应用于金融记录、电子投票、事件审计和合规性要求等领域，确保数据的透明性和可信度。


## Merkle tree

Merkle树是一种数据结构，广泛用于区块链和分布式系统中，以高效和安全地验证和管理大量数据。其主要特点包括：

二叉树结构：Merkle树由多个叶子节点（数据块的哈希值）和内部节点（由子节点的哈希值组合而成）构成。每个非叶子节点是其子节点哈希值的哈希。

高效的完整性验证：通过Merkle树，可以快速验证特定数据块是否在树中，而不需要检查所有数据。这对于处理大量数据时非常高效。

防篡改性：由于每个节点的哈希依赖于其子节点，任何对叶子节点数据的修改都会影响整个树的哈希值，确保数据的完整性和防篡改性。

分布式存储：Merkle树使得在分布式系统中，节点可以只存储部分数据并仍能有效验证完整性。这对区块链等系统尤其重要，因为节点不必存储整个数据集。

应用广泛：Merkle树在区块链（如比特币）、文件系统（如Git）、P2P网络和其他需要高效数据验证的场景中都有广泛应用。

Merkle树的设计使其能够在保证安全性的同时，提高数据管理的效率。

## 全节点和轻节点

轻节点只包含 Block header，如钱包。

在区块链中，全节点和轻节点（或称为“轻客户端”）是两种不同类型的网络参与者，具有不同的功能和特性：

全节点
完整数据存储：全节点下载并存储整个区块链的所有数据，包括每个区块和交易。
验证功能：负责验证所有交易和区块的有效性，确保网络的安全性和一致性。
网络参与：可以向其他节点传播交易和区块，并参与共识机制。
资源消耗高：由于需要大量存储和计算能力，全节点通常对硬件要求较高。
轻节点
部分数据存储：轻节点只下载区块链的头部信息，而不存储完整的交易数据。
依赖全节点：通过查询全节点获取所需的数据和验证交易，节省存储和计算资源。
快速和灵活：轻节点启动速度快，适合移动设备和资源有限的环境。
安全性较低：由于依赖于全节点进行数据验证，轻节点在一定程度上受到信任模型的影响。
总结来说，全节点提供了更高的安全性和完整性，而轻节点则提供了更高的便利性和资源效率，适用于不同的使用场景。

### Block header

区块头（Block Header）是区块链中每个区块的重要组成部分，包含关于该区块的关键信息。区块头的主要字段通常包括：

版本号（Version）：区块链协议的版本，用于指示区块的格式和规则。

前一区块哈希（Previous Block Hash）：指向前一个区块的哈希值，确保区块链的顺序和完整性。

时间戳（Timestamp）：区块被创建的时间，通常以Unix时间格式表示。

难度目标（Difficulty Target）：表示当前区块的挖掘难度，用于调整挖掘过程的难度。

Nonce：一个随机数，矿工在挖掘过程中调整此值以找到有效的哈希值。

默克尔根（Merkle Root）：该区块中所有交易哈希的根哈希，确保区块内交易的完整性和安全性。

区块头的设计使得每个区块可以有效地链接到前一个区块，形成不可篡改的链条，同时通过包含必要的元数据，支持网络的共识和验证机制。


### Block body 

区块体（Block Body）是区块链中区块的一个组成部分，包含实际的交易数据或其他信息。其主要特点包括：

交易列表：区块体通常包含一系列交易记录，具体列出在该区块中确认的所有交易，包括发送方、接收方、金额等详细信息。

交易数量：区块体中可能还会记录交易的数量，便于网络参与者了解该区块的活动程度。

其他数据：在某些区块链中，区块体还可以包含其他类型的数据，如智能合约的执行结果、状态变更等。

数据结构：区块体的数据通常以特定的格式存储，例如使用默克尔树（Merkle Tree）来高效组织和验证交易，提高数据的完整性和检索速度。

区块体和区块头共同构成完整的区块，区块头提供元数据和验证信息，而区块体则包含具体的业务数据或交易记录。

### Merkle proof

Merkle证明（Merkle Proof）是一种用于验证某个特定数据项是否存在于Merkle树中的方法。其主要特点包括：

高效验证：Merkle证明允许验证者在不知道整个树的情况下，仅凭少量信息（哈希值）验证特定数据的存在性。

包含路径：Merkle证明通常包括一系列的哈希值，这些哈希值构成了从目标叶子节点到根节点的路径。验证者可以使用这些哈希值重建默克尔根。

抗篡改性：如果某个数据项被篡改，相应的哈希值也会变化，因此Merkle证明能够确保数据的完整性。

使用场景：Merkle证明广泛应用于区块链和分布式系统中，尤其是在轻节点与全节点之间的交互中，允许轻节点验证某项交易是否在区块中而不需下载整个区块。

Merkle证明通过有效利用Merkle树的结构，提高了数据验证的效率和安全性。


### Proof of membership/Proof of inclusion

成员证明（Proof of Membership）或包含证明（Proof of Inclusion）是用于验证某个特定数据项是否属于某个集合或数据结构（如Merkle树）的一种方法。其主要特点包括：

验证性：通过提供必要的哈希值和路径信息，允许验证者确认某个数据项确实存在于集合中。

高效性：只需少量数据（通常是一些哈希值）即可进行验证，而无需获取整个数据集合，节省了存储和带宽。

抗篡改性：由于基于哈希函数的性质，任何对数据项的篡改都会导致不同的哈希值，从而使证明无效，确保数据的完整性。

应用场景：在区块链、分布式账本和文件系统中，成员证明常用于轻节点验证交易是否在某个区块中，确保交易的有效性和真实性。

通过这些特性，成员证明增强了系统的安全性和效率，使得数据的验证过程更加灵活和快速。

对数级（O(log n)）的效率。

### Sort Merkle tree

排序默克尔树（Sorted Merkle Tree）是一种特殊类型的默克尔树，旨在在树的结构中保留数据项的排序信息。其主要特点包括：

有序性：节点按特定顺序排列，通常是按键值顺序。这使得数据项在树中有明确的顺序关系，便于查找和验证。

高效验证：通过保留排序信息，排序默克尔树可以在进行成员证明时，快速验证特定数据项是否存在并且在正确的位置。

增强的查找性能：由于数据项是有序存储的，排序默克尔树在执行某些查询操作（如范围查询）时可能比普通默克尔树更高效。

应用场景：排序默克尔树适用于需要保持数据有序性并进行高效验证的场景，如区块链、数据库索引等。

通过这些特性，排序默克尔树在确保数据完整性和安全性的同时，也提高了数据访问的效率。

比特币没有使用Sort Merkle tree。






